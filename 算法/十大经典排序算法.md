### 十大经典排序算法
本文所示排序算法均以升序排序为例
#### 冒泡排序
可以想象生活中一个细管内大小不同的水泡（假定它们只能上下排列），大的水泡比较重会沉入水底，在大水泡下沉的过程中会与比它小的水泡交换位置，由于空间狭窄，他们只能两辆交换位置。冒泡排序的过程就是每次将大水泡下沉，直到所有水泡按从上到下由小到大的有序队列的过程。
* 算法描述：
1. 定义两个指针，分别指向相邻的元素，如果前面的元素比后面的元素大，则交换位置
2. 对每一对元素进行同样的操作，第一次操作后找到最大值，第二次循环后找到次大值，一次类推。因此数组的后面已为升序，不需要每次都遍历
3. 如果有n个元素，重复上述操作n-1次（为什么是n-1？因为第n-2次的时候最多只有两个泡泡顺序存在问题，一个泡泡站好了，另一个泡泡也就站好了）
* 代码实现
  ```
  function bubbleSort(array) {
    for (let i = 0; i < array.length - 1; i++){
      // 外层循环完成一次，最后找出一个最值
      for (let j = 0; j < array.length - 1 - i; j++){
        if (array[j] > array[j + 1]) {
          [array[j], array[j+1]] = [array[j+1], array[j]]
        }
      }
    }
    return array
  }
  ```
* 时空复杂度分析
在冒泡的过程中使用的是两两交换位置，不需要额外的空间，空间复杂度为O(1)。两层循环，所以时间复杂度最差为O(n^2^)

#### 选择排序
不断的在未排序的数组中寻找最小的元素，然后与排序的起始位置交换顺序。n个元素经过n-1次选择排序后得到有序结果
* 算法描述
1. 选中没有排序的首位为最小值，然后在后面找到比首位更小的值，如果找到就记录位置，然后交换位置。
2. 假设n个元素，第i（i < n-1）次时，无序区为[i, n]，有序区为[0, i-1]
* 代码实现
  ```
  function selectionSort(array) {
  for (let i = 0; i < array.length -1; i++){
    let minIndex = i
    for (let j = i + 1; j < array.length; j++){
      if (array[j] < array[minIndex]) {
        // 找到最大值的位置
        minIndex = j
      }
    }
    // 交换
    [array[i], array[minIndex]] = [array[minIndex], array[i]]
  }
  return array
  }
  ```
* 时空复杂读分析
不需要额外的空间，所以空间复杂度为O(1)。最坏的情况时间复杂度为O(n^2^)
